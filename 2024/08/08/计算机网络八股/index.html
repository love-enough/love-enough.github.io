

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="GuoZihan">
  <meta name="keywords" content="">
  
    <meta name="description" content="对一些常见的计算机网络面试题进行整理，大部分资料来源于网上资源，拒绝转载!">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络八股">
<meta property="og:url" content="https://love-enough.github.io/2024/08/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1/index.html">
<meta property="og:site_name" content="无所畏惧的man">
<meta property="og:description" content="对一些常见的计算机网络面试题进行整理，大部分资料来源于网上资源，拒绝转载!">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://love-enough.github.io/2024/08/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1/index.png">
<meta property="article:published_time" content="2024-08-08T08:34:23.000Z">
<meta property="article:modified_time" content="2024-08-09T03:00:02.297Z">
<meta property="article:author" content="GuoZihan">
<meta property="article:tag" content="八股">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://love-enough.github.io/2024/08/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1/index.png">
  
  
  
  <title>计算机网络八股 - 无所畏惧的man</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/scrollAnimation.css">
<link rel="stylesheet" href="/css/selection.css">
<link rel="stylesheet" href="/css/mk.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"love-enough.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"6yoTduI2I2n2uTiOyxHOpVNZ-gzGzoHsz","app_key":"CuG32gSXDFOZPtNyZjx6BOYR","server_url":"https://6yotdui2.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>无所畏惧的man</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/post.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="计算机网络八股"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        GuoZihan
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-08-08 16:34" pubdate>
          2024年8月8日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          9.6k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          81 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">计算机网络八股</h1>
            
              <p id="updated-time" class="note note-info" style="">
                
                  
                    本文最后更新于 2024年8月9日 上午
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h1 id="计算机网络八股"><a href="#计算机网络八股" class="headerlink" title="计算机网络八股"></a>计算机网络八股</h1><h4 id="计算机五层模型"><a href="#计算机五层模型" class="headerlink" title="计算机五层模型"></a>计算机五层模型</h4><ul>
<li><p><strong>物理层</strong>：负责把两台计算机连起来，然后在计算机之间通过高低电频来传送0,1这样的电信号，比如通过一些电缆线传输比特流。</p>
</li>
<li><p><strong>链路层</strong>：链路层涉及到的协议比较多，比如 Mac 地址啊，ARP 等，这一层主要就是负责数据的通信，使各节点之间可以通信，比如通过 MAC 地址唯一识别不同的节点，通过以太网协议定义数据包等。</p>
</li>
<li><p><strong>网络层</strong>：网络层负责把一个数据从一个网络传递到另外一个网络，最大的功能就是进行<strong>路由决策</strong>，比如通过 IP，子网等概念，使数据更好着在不同的局域网中传递。</p>
</li>
<li><p><strong>传输层</strong>：传输层的功能就是建立端口到端口的通信，刚才说的网络层的功能则是建立主机到主机的通信，比如通过网络层我们可以把信息从 A 主机传递到 B 主机，但是 B 主机有多个程序，我们具体要发给哪个程序，则是靠传输层的协议来识别，常见协议有 UDP 和 TCP。</p>
</li>
<li><p><strong>应用层</strong>：虽然我们收到了传输层传来的数据，可是这些传过来的数据五花八门，有html格式的，有mp4格式的，各种各样，我们用户也看不懂，</p>
<p>因此我们需要指定这些数据的格式规则，收到后才好解读渲染。例如我们最常见的 Http 数据包中，就会指定该数据包是 什么格式的文件了。</p>
</li>
</ul>
<h3 id="IP地址和Mac地址有啥区别"><a href="#IP地址和Mac地址有啥区别" class="headerlink" title="IP地址和Mac地址有啥区别"></a>IP地址和Mac地址有啥区别</h3><p>简洁来说的话，就是：IP处于网络层，主要用来寻址，如同我们的快递地址，有个地址方便寻找大致的地点，而MAC地址，则用来唯一确认身份，就像我们的身份证。</p>
<ul>
<li>IP地址是逻辑地址，而MAC地址是物理地址。</li>
<li>IP地址是在网络层使用的地址，用于标识网络上的主机或路由器，MAC地址则是在数据链路层使用的地址，用于标识网络上的网卡或其他物理设备。</li>
<li>IP地址是可变的，可以在网络上动态分配或更改，而MAC地址是固定的，通常是出厂时设定的。</li>
<li>IP地址是全球唯一的，由互联网号码分配机构（IANA）管理分配，而MAC地址是由设备厂商分配，通常在设备生产时就已经固定。</li>
</ul>
<h3 id="说一说三次握手"><a href="#说一说三次握手" class="headerlink" title="说一说三次握手"></a>说一说三次握手</h3><p><img src="/2024/08/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1/image-20240808165309884.png" srcset="/img/loading.gif" lazyload alt="三次握手"></p>
<p><strong>刚开始客户端处于 closed 的状态，服务端处于 listen 状态</strong>。然后</p>
<ul>
<li><p>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 **ISN(c)**。此时客户端处于 <strong>SYN_Send</strong> 状态。</p>
</li>
<li><p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 <strong>SYN_REVD</strong> 的状态。</p>
</li>
<li><p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 <strong>establised</strong> 状态。</p>
</li>
<li><p>服务器收到 ACK 报文之后，也处于 <strong>establised 状态</strong>，此时，双方以建立起了链接</p>
</li>
</ul>
<p><img src="/2024/08/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1/image-20240808165930950.png" srcset="/img/loading.gif" lazyload alt="为什么只能是三次握手"></p>
<h3 id="三次握手的作用"><a href="#三次握手的作用" class="headerlink" title="三次握手的作用"></a>三次握手的作用</h3><ul>
<li>确认双方的接受能力、发送能力是否正常。</li>
<li>指定自己的初始化序列号，为后面的可靠传送做准备。</li>
</ul>
<h3 id="ISN是固定的吗"><a href="#ISN是固定的吗" class="headerlink" title="ISN是固定的吗"></a>ISN是固定的吗</h3><p>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p>
<p>如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 <strong>ISN 是动态生成的</strong>。</p>
<h3 id="什么是半连接队列"><a href="#什么是半连接队列" class="headerlink" title="什么是半连接队列"></a>什么是半连接队列</h3><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为<strong>半连接队列</strong>。当然还有一个<strong>全连接队列</strong>，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p>
<h3 id="三次握手可以携带数据吗"><a href="#三次握手可以携带数据吗" class="headerlink" title="三次握手可以携带数据吗"></a>三次握手可以携带数据吗</h3><p>其实第三次握手的时候，是可以携带数据的。也就是说，<strong>第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的</strong>。</p>
<blockquote>
<p>为什么这样呢？大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。</p>
</blockquote>
<p>而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据页没啥毛病。</p>
<h3 id="说一说四次挥手"><a href="#说一说四次挥手" class="headerlink" title="说一说四次挥手"></a>说一说四次挥手</h3><p><img src="/2024/08/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1/image-20240808170711411.png" srcset="/img/loading.gif" lazyload alt="四次挥手"></p>
<p><strong>刚开始双方都处于 establised 状态，假如是客户端先发起关闭请求</strong>，则：</p>
<ul>
<li><p>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于<strong>FIN_WAIT1</strong>状态。（大白话：相当于客户端告诉服务端，我想断开链接了）</p>
</li>
<li><p>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <strong>CLOSE_WAIT</strong>状态。（大白话：相当于，服务端告诉客户端，好的，我收到你的断开请求了）</p>
</li>
<li><p>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <strong>LAST_ACK</strong> 的状态。</p>
</li>
<li><p>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 <strong>TIME_WAIT</strong> 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态</p>
</li>
<li><p>服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</p>
</li>
</ul>
<p>这里特别需要主要的就是<strong>TIME_WAIT</strong>这个状态了，这个是面试的高频考点，就是要理解，为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，<strong>要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文</strong>。</p>
<h3 id="说一说TCP和UDP的区别"><a href="#说一说TCP和UDP的区别" class="headerlink" title="说一说TCP和UDP的区别"></a>说一说TCP和UDP的区别</h3><ul>
<li>TCP是面向连接的传输层协议，所谓面向连接就是双方传输数据之前，必须先建立一条通道，例如三次握手就是建议通道的一个过程，而四次挥手则是结束销毁通道的一个其中过程；而 UDP 则是无连接的传输协议。</li>
<li>TCP 可以提供可靠的传输，比如数据丢失，超时，TCP 都会重传，并且数据包也能够按序到达，而 UDP 是不可靠的，数据丢失了也不会重传等等。</li>
</ul>
<p>从效率的角度讲，UDP 的效率更快，因为 UDP 不需要做诸如三次握手&#x2F;四次挥手&#x2F;重传等额外的消耗。</p>
<p>从应用场景角度讲的话，对信息的正确率要求比较高的可以采用 TCP 协议，比如我们平时常见的文字聊天；而允许出现小部分数据丢失的，则可以采用 UDP，比如视频聊天等。</p>
<h3 id="TCP和UDP分别对应的常见应用层协议有哪些"><a href="#TCP和UDP分别对应的常见应用层协议有哪些" class="headerlink" title="TCP和UDP分别对应的常见应用层协议有哪些"></a>TCP和UDP分别对应的常见应用层协议有哪些</h3><p>TCP对应的应用层协议</p>
<ul>
<li>FTP：定义了文件传输协议，使用 21 端口。</li>
<li>Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于 DOS 模式下的通信服务。</li>
<li>SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件，服务器开放的是 25 号端口。。</li>
<li>POP3：它是和 SMTP 对应，POP3 用于接收邮件。通常情况下，POP3 协议所用的是 110 端口。</li>
<li>HTTP：超文本传输协议，从 Web 服务器传输超文本到本地浏览器的传送协议。</li>
</ul>
<p>UDP对应的应用层协议</p>
<ul>
<li>DNS：用于域名解析服务，将域名地址转换为 IP 地址。DNS 用的是 53 号端口。</li>
<li>SNMP：简单网络管理协议，使用 161 号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</li>
<li>TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口 69 上使用 UDP 服务。</li>
</ul>
<h3 id="浏览器对同一Host建立TCP连接的数量有无限制"><a href="#浏览器对同一Host建立TCP连接的数量有无限制" class="headerlink" title="浏览器对同一Host建立TCP连接的数量有无限制"></a>浏览器对同一Host建立TCP连接的数量有无限制</h3><p>浏览器对同一Host建立的TCP连接数量是有限制的。这个限制情况主要依赖于浏览器的类型和版本，以及特定的浏览器配置。</p>
<p>以HTTP&#x2F;1.1协议为例，根据其规范，对于同一个给定的域，大多数浏览器限制同时打开的TCP连接数量为6个到8个。这意味着，如果一个网页需要获取该域下的更多资源，可能需要等待前面的请求完成。</p>
<p>在HTTP&#x2F;2协议中，对于同一个域，所有的请求都可以在同一个持久连接中并行完成，从而减少了所需的连接数量。</p>
<p>这个限制只针对同一个Host。如果一个网页的资源分布在不同的Host上，那么浏览器可以分别针对这些Host建立连接。因此，使用多个子域去托管网站的资源是一种常见的绕过浏览器连接限制的方式，以提高加载效率。</p>
<h3 id="说一说HTTP1-0-1-1-2-0区别"><a href="#说一说HTTP1-0-1-1-2-0区别" class="headerlink" title="说一说HTTP1.0,1.1,2.0区别"></a>说一说HTTP1.0,1.1,2.0区别</h3><p>HTTP&#x2F;1.0中浏览器与服务器<strong>只保持短暂的连接，连接无法复用</strong>。也就是说每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</p>
<p>为了解决HTTP&#x2F;1.0存在的缺陷，最主要的改进就是引入了持久连接。所谓的持久连接即<strong>TCP连接默认不关闭，可以被多个请求复用</strong>。客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。或者客户端在最后一个请求时，主动告诉服务端要关闭连接。HTTP&#x2F;1.1版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</p>
<p>HTTP&#x2F;2 为了解决HTTP&#x2F;1.1中仍然存在的效率问题，HTTP&#x2F;2 采用了<strong>多路复用</strong>。即在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。能这样做有一个前提，就是HTTP&#x2F;2进行了<strong>二进制分帧</strong>，即 HTTP&#x2F;2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码。除此之外，还有一些其他的优化，比如做Header压缩、服务端推送等。</p>
<blockquote>
<p>也就是说，老板可以同时下达多个命令，员工也可以收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。A请求的两部分响应在组合到一起发给老板。</p>
</blockquote>
<h3 id="HTTP有哪些常用的状态码及使用场景"><a href="#HTTP有哪些常用的状态码及使用场景" class="headerlink" title="HTTP有哪些常用的状态码及使用场景"></a>HTTP有哪些常用的状态码及使用场景</h3><p><strong>状态码分类</strong></p>
<ul>
<li>1xx：表示目前是协议的中间状态，还需要后续请求</li>
<li>2xx：表示请求成功</li>
<li>3xx：表示重定向状态，需要重新请求</li>
<li>4xx：表示请求报文错误</li>
<li>5xx：服务器端错误</li>
</ul>
<p><strong>常用状态码</strong></p>
<ul>
<li>200 请求成功，有响应体</li>
<li>403 服务器禁止访问</li>
<li>404 资源未找到</li>
<li>400 请求错误</li>
<li>500 服务器端错误</li>
<li>503 服务器繁忙</li>
</ul>
<h3 id="说一下ARP协议的工作原理"><a href="#说一下ARP协议的工作原理" class="headerlink" title="说一下ARP协议的工作原理"></a>说一下ARP协议的工作原理</h3><p>网络层的 ARP（地址解析协议） 协议完成了 <strong>IP 地址与物理地址的映射</strong>。可以让我们通过 IP 地址获取到对应的 MAC 地址</p>
<blockquote>
<p>首先，每台主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址的对应关系。</p>
<p>当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP 列表中是否存在该 IP 地址对应的 MAC 地址：如果有，就直接将数据包发送到这个 MAC 地址；如果没有，就向本地网段发起一个 ARP 请求的广播包，查询此目的主机对应的 MAC 地址。</p>
<p>此 ARP 请求数据包里包括源主机的 IP 地址、硬件MAC地址、以及目的主机的 IP 地址。</p>
<p>网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后给源主机发送一个 ARP 响应数据包，告诉对方自己是它需要查找的 MAC 地址；源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败</p>
</blockquote>
<h3 id="说一说保活计时器"><a href="#说一说保活计时器" class="headerlink" title="说一说保活计时器"></a>说一说保活计时器</h3><p>TCP 有一个保活计时器（keepalive timer）。设想这样的场景：客户已主动与服务器建立了 TCP 连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。</p>
<p>服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10个 探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。</p>
<h3 id="说一说流量控制"><a href="#说一说流量控制" class="headerlink" title="说一说流量控制"></a>说一说流量控制</h3><p>TCP流量控制是一种内置于TCP协议的机制，用于防止发送方把接收方的缓冲区塞满，以避免数据丢失。简单地说，就是保证发送者不会将数据发送得过快，导致接收者无法接收。</p>
<p>TCP流量控制的工作方式是每个TCP段都有一个窗口大小字段，这个字段告诉发送者接收端的可用缓冲区大小。接收方通过更改这个窗口大小值来告诉发送方他还能接收多少数据。如果接收方的缓冲区被填满了，它就会将窗口大小设置为0，这时发送方就会停止发送数据，直到接收方再次更新其窗口大小。</p>
<h3 id="TCP如何实现流量控制"><a href="#TCP如何实现流量控制" class="headerlink" title="TCP如何实现流量控制"></a>TCP如何实现流量控制</h3><p>TCP实现流量控制主要依赖于滑动窗口机制。滑动窗口不仅是一种流量控制手段，也是一种可靠传输的手段。它的基本思想是：每个TCP连接都有两个窗口，一个是发送窗口，另一个是接收窗口。窗口大小是动态变化的。</p>
<p>发送窗口的大小由自己和接收方协商得出，不能超过接收窗口的大小。当发送方发送数据时，会根据窗口的大小来确定可以发送的数据量。当数据发送出去后，发送窗口就会向右滑动。接收方在接收到数据后，会向发送方发送确认，确认号表示的是接收方期望接收的下一个数据字节的序号，同时还会告诉发送方自己的接收窗口大小。如果接收方处理数据的速度慢，那么接收窗口的大小就会减小，甚至变为0，此时发送方就不能再发送数据，这样就实现了流量控制。</p>
<h3 id="什么是滑动窗口"><a href="#什么是滑动窗口" class="headerlink" title="什么是滑动窗口"></a>什么是滑动窗口</h3><p><img src="/2024/08/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1/image-20240808181348182.png" srcset="/img/loading.gif" lazyload alt="滑动窗口"></p>
<h3 id="讲一下什么是TPC粘包和拆包"><a href="#讲一下什么是TPC粘包和拆包" class="headerlink" title="讲一下什么是TPC粘包和拆包"></a>讲一下什么是TPC粘包和拆包</h3><p><strong>TCP粘包</strong>：简单来说，就是发送方发送的若干包数据到达接收方时被“粘”在一起，接收方看到的可能是一个大的数据包。这主要是因为TCP是一个基于字节流的协议，没有边界。另一个原因是为了提高网络的有效利用率，TCP会尽可能地将小的数据包合并到大的数据包中发送出去。</p>
<p><strong>TCP拆包</strong>：与TCP粘包相反，拆包是指发送方发送的一个大的数据包到达接收方时被“拆”成多个小的数据包。这主要是因为TCP在传输数据时，如果数据包过大，会被分割成合适大小的小包进行发送，以适应网络的最大传输单元</p>
<p><strong>解决这个问题的常见方法是在应用层添加消息边界，比如使用特殊的分隔符，或者在消息头部添加长度字段，来标识每个消息的边界。</strong></p>
<h3 id="HTTP常见的方法有哪些"><a href="#HTTP常见的方法有哪些" class="headerlink" title="HTTP常见的方法有哪些"></a>HTTP常见的方法有哪些</h3><ul>
<li><strong>GET</strong>：用于请求服务器返回指定资源的数据。</li>
<li><strong>POST</strong>：用于向服务器提交数据，请求服务器处理请求中的数据。</li>
<li><strong>PUT</strong>：用于向服务器上传或更新资源，请求服务器存储请求中的数据。</li>
<li><strong>DELETE</strong>：用于请求服务器删除指定的资源。</li>
<li><strong>HEAD</strong>：类似于GET请求，但不返回具体的资源数据，而只返回资源的元信息（例如响应头部），用于获取资源的元信息而不获取实际的资源内容。</li>
<li><strong>OPTIONS</strong>：查询服务器支持的HTTP方法。</li>
<li><strong>TRACE</strong>：用于向服务器发送一个请求，服务器将此请求返回给客户端，用于追踪请求的路径。</li>
</ul>
<h3 id="说一说POST和GET有哪些区别"><a href="#说一说POST和GET有哪些区别" class="headerlink" title="说一说POST和GET有哪些区别"></a>说一说POST和GET有哪些区别</h3><ul>
<li><strong>使用场景</strong>：GET 用于获取资源，而 POST 用于传输实体主体。</li>
<li><strong>参数</strong>：GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。</li>
<li><strong>安全性</strong>：安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</li>
<li><strong>幂等性</strong>：幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。GET方法是幂等性的，而POST方法不是。</li>
<li><strong>可缓存</strong>：请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li>
</ul>
<h3 id="在浏览器中输入URL地址到显示主页的过程"><a href="#在浏览器中输入URL地址到显示主页的过程" class="headerlink" title="在浏览器中输入URL地址到显示主页的过程"></a>在浏览器中输入URL地址到显示主页的过程</h3><ul>
<li><strong>URL解析</strong>：浏览器首先会解析你输入的URL，确定你要访问的是哪个网站，这个网站的地址（IP地址）是什么，以及你请求访问该网站的具体页面路径。</li>
<li><strong>DNS查询</strong>：如果浏览器缓存或系统缓存中没有该域名的IP地址，那么浏览器将发送一个请求到DNS（域名系统）服务器，来查找对应的IP地址。</li>
<li><strong>建立连接</strong>：找到IP地址后，浏览器会向该地址发送一个TCP连接请求，这个过程通常被称为TCP的三次握手。</li>
<li><strong>发送HTTP请求</strong>：一旦TCP连接被建立，浏览器就可以通过这个连接向服务器发送HTTP请求了。这个请求里会包含你要获取的资源类型，所使用的HTTP版本，以及可能的一些其他信息。</li>
<li><strong>服务器处理请求并返回HTTP响应</strong>：服务器接收到HTTP请求后，进行处理，然后返回一个HTTP响应，响应中包含了要访问的网页的内容，以及一些描述信息，如状态码、内容类型等。</li>
<li><strong>浏览器解析HTML</strong>：浏览器接收到服务器的响应数据后，开始解析HTML，构建DOM树。</li>
<li><strong>资源加载</strong>：在解析HTML的过程中，如果遇到CSS、JavaScript文件或者图片等资源，浏览器会再次发送HTTP请求去获取。</li>
<li><strong>浏览器渲染页面</strong>：在获取到所有的资源文件后，浏览器开始渲染页面，将资源文件转化为网页上的可视、可交互的内容。</li>
<li><strong>关闭连接</strong>：如果HTTP头部中的<code>Connection</code>字段的属性被设置为<code>close</code>，那么浏览器和服务器的TCP连接在传输完成后将会被关闭。如果设置为<code>keep-alive</code>，那么TCP连接会被保持一段时间，以便传输更多的请求。</li>
</ul>
<h3 id="说一说DNS解析过程"><a href="#说一说DNS解析过程" class="headerlink" title="说一说DNS解析过程"></a>说一说DNS解析过程</h3><p>DNS（Domain Name System）是互联网中用于将域名解析为IP地址的系统。</p>
<ul>
<li>用户在浏览器中输入一个域名，比如<a target="_blank" rel="noopener" href="http://www.example.com./">www.example.com。</a></li>
<li>浏览器首先会在本地缓存中查找是否有该域名对应的IP地址，如果有则直接返回IP地址，否则进入下一步。</li>
<li>浏览器会向本地DNS服务器发送一个查询请求。</li>
<li>本地DNS服务器如果缓存中有该域名对应的IP地址，则直接返回IP地址给浏览器，否则进入下一步。</li>
<li>本地DNS服务器会向根域名服务器发送一个查询请求，询问该域名的顶级域名服务器（比如.com）的IP地址。</li>
<li>根域名服务器会返回顶级域名服务器的IP地址给本地DNS服务器。</li>
<li>本地DNS服务器再次向顶级域名服务器发送查询请求，询问该域名的权威域名服务器（比如example.com）的IP地址。</li>
<li>权威域名服务器返回该域名的IP地址给本地DNS服务器。</li>
<li>本地DNS服务器最后将IP地址返回给浏览器。</li>
<li>浏览器得到IP地址后，就可以向该IP地址对应的服务器发送HTTP请求，建立起与服务器的连接，开始浏览网页</li>
</ul>
<h3 id="为了DNS解析更多，你觉得可用到哪些优化手段"><a href="#为了DNS解析更多，你觉得可用到哪些优化手段" class="headerlink" title="为了DNS解析更多，你觉得可用到哪些优化手段"></a>为了DNS解析更多，你觉得可用到哪些优化手段</h3><ul>
<li><strong>DNS缓存</strong>：DNS缓存是本地DNS服务器和浏览器中的一种机制，用于缓存已解析的域名和对应的IP地址。当再次访问相同域名时，可以直接从缓存中获取IP地址，避免重复查询和延迟。</li>
<li><strong>域名预取</strong>：浏览器可以在用户点击链接之前提前解析网页中的链接中的域名，将这些域名解析为IP地址并缓存起来。这样当用户点击链接时，可以立即建立连接，减少等待时间</li>
</ul>
<h3 id="什么是HTTP长连接"><a href="#什么是HTTP长连接" class="headerlink" title="什么是HTTP长连接"></a>什么是HTTP长连接</h3><p>HTTP长连接（HTTP persistent connection）是指在一次HTTP请求和响应完成后，保持TCP连接不关闭，以便后续的HTTP请求可以继续在同一个连接上发送和接收数据。</p>
<p>在传统的HTTP&#x2F;1.0版本中，每次请求完成后，TCP连接都会被关闭，下次请求需要重新建立连接，这种方式称为<strong>短连接</strong>。而在HTTP&#x2F;1.1版本中，引入了持久连接的概念，也就是HTTP长连接。</p>
<p>HTTP长连接的主要优势在于减少了TCP连接建立和关闭的开销，提高了性能和效率。相比于短连接，HTTP长连接可以避免频繁地进行握手和挥手操作，节省了网络资源和服务器端的负担，特别适用于同时请求多个资源，或在一个页面中含有多个嵌入资源的情况。。</p>
<h3 id="HTTP长连接短连接使用场景是什么"><a href="#HTTP长连接短连接使用场景是什么" class="headerlink" title="HTTP长连接短连接使用场景是什么"></a>HTTP长连接短连接使用场景是什么</h3><ul>
<li><strong>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况</strong>。</li>
<li>而像 WEB 网站的 http 服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像 WEB 网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源， 如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以<strong>并发量大，但每个用户无需频繁操作情况下需用短连接</strong>。</li>
</ul>
<h3 id="HTTP和HTTPS的区别有哪些"><a href="#HTTP和HTTPS的区别有哪些" class="headerlink" title="HTTP和HTTPS的区别有哪些"></a>HTTP和HTTPS的区别有哪些</h3><ul>
<li><strong>安全性</strong>：HTTP是明文传输的协议，数据并没有经过加密，容易被窃听、篡改或其他安全风险。HTTPS通过使用SSL（安全套接层）或TLS（传输层安全）协议对HTTP进行加密，确保数据在传输过程中的安全性和完整性。这样，即使被截获的数据也无法被解读和篡改。</li>
<li><strong>端口号</strong>：HTTP默认使用端口号80进行通信。HTTPS默认使用端口号443进行通信。</li>
<li><strong>证书</strong>：HTTPS使用数字证书对网站的身份进行认证。证书由可信的第三方机构颁发，用于证明服务器是可信的，并且可以用来加密和解密通信过程中的数据。HTTP不需要证书，任何人都可以发送HTTP请求和接收HTTP响应。</li>
<li><strong>性能开销</strong>：由于HTTPS需要进行加密和解密操作，因此相对于HTTP来说，会有更多的计算和处理开销，会轻微地增加通信的延迟和资源消耗。</li>
</ul>
<h3 id="HTTP报文常见的字段有哪些"><a href="#HTTP报文常见的字段有哪些" class="headerlink" title="HTTP报文常见的字段有哪些"></a>HTTP报文常见的字段有哪些</h3><p><strong>请求报文</strong></p>
<ul>
<li>请求行字段<ul>
<li>方法（Method）：定义请求的动作，常见的方法有GET、POST、PUT、DELETE等。</li>
<li>URL（Uniform Resource Locator）：指定请求的资源路径和参数。</li>
<li>协议版本（HTTP Version）：定义使用的HTTP协议版本，如HTTP&#x2F;1.1。</li>
</ul>
</li>
<li>请求头字段<ul>
<li>Host：指定要访问的服务器的主机名。</li>
<li>User-Agent：发送请求的用户代理信息，表示浏览器、操作系统等。</li>
<li>Accept：客户端能够接收的响应内容类型。</li>
<li>Content-Type：请求体中的数据类型。</li>
<li>Cookie：在之前与服务器建立的会话中存储的Cookie信息。</li>
<li>Authorization：用于提供身份验证凭据的信息。</li>
</ul>
</li>
<li>请求体字段<ul>
<li>Content-Type：请求体中的数据类型。</li>
<li>Content-Length：请求体的字节数。</li>
<li>请求体内容：传输的实际数据。</li>
</ul>
</li>
</ul>
<p><strong>响应报文</strong></p>
<ul>
<li>状态行字段<ul>
<li>协议版本（HTTP Version）：定义使用的HTTP协议版本，如HTTP&#x2F;1.1。</li>
<li>状态码（Status Code）：表示服务器对请求的处理结果，如200表示成功，404表示未找到等。</li>
<li>状态信息（Status Text）：对状态码的简要描述。</li>
</ul>
</li>
<li>响应头字段<ul>
<li>Content-Type：响应体中的数据类型。</li>
<li>Content-Length：响应体的字节数。</li>
<li>Set-Cookie：服务器通过响应头中的Set-Cookie字段向客户端发送新的Cookie。</li>
</ul>
</li>
<li>响应体字段<ul>
<li>实际的响应数据。</li>
</ul>
</li>
</ul>
<h3 id="HTTPS的大概流程讲一下"><a href="#HTTPS的大概流程讲一下" class="headerlink" title="HTTPS的大概流程讲一下"></a>HTTPS的大概流程讲一下</h3><ul>
<li>客户端发起连接：客户端通过浏览器等应用向服务器发送HTTPS请求。请求的URL以https:&#x2F;&#x2F;开头，表明是要使用HTTPS协议进行通信。</li>
<li>服务器证书：服务器接收到来自客户端的HTTPS请求后，会将自己的数字证书发送给客户端。<strong>证书中包含了服务器的公钥</strong>，同时由可信的权威机构（证书颁发机构，CA）对服务器的身份进行认证。</li>
<li>客户端收到服务端的证书后，<strong>会对证书进行验证</strong><ul>
<li>验证证书的合法性：客户端会检查证书的有效期、签发机构和相关属性，确保证书的合法性。</li>
<li>验证证书的可信性：客户端会检查证书的颁发机构是否被信任，以确保证书是由可信的第三方机构颁发的。</li>
</ul>
</li>
<li>密钥交换：在证书验证通过后，客户端会生成一个随机的对称加密密钥（session key），并<strong>使用服务器的公钥进行加密</strong>。然后将加密后的密钥发送给服务器。</li>
<li>会话加密：服务器收到客户端发送的加密密钥后，<strong>使用自己的私钥进行解密</strong>，得到对称加密密钥（session key）。客户端和服务器都会使用这个对称密钥来加密和解密后续的通信数据。</li>
<li>安全通信：客户端和服务器之间的所有通信都会使用对称密钥进行加密和解密。这样，即使有人拦截到通信数据，也无法解密和获取其中的内容。</li>
</ul>
<h3 id="什么是数字证书"><a href="#什么是数字证书" class="headerlink" title="什么是数字证书"></a>什么是数字证书</h3><p>一个数字证书是一个文件，经过由信任的证书颁发机构（CA，Certificate Authority）数字签名，用以验证持有者的身份以及公钥的真实性。简短来说，就是一个电子文档，用来证明持有者的身份和公钥所有权。</p>
<p>举个例子，当你访问一个https开头的网站，如<a target="_blank" rel="noopener" href="https://www.google.com时,你的浏览器会先获取google的数字证书,进一步验证其合法性.如果验证成功,且证书匹配服务器的域名,表示证书是真实有效的,浏览器就会允许连接建立,进一步加载网页数据./">https://www.google.com时，你的浏览器会先获取Google的数字证书，进一步验证其合法性。如果验证成功，且证书匹配服务器的域名，表示证书是真实有效的，浏览器就会允许连接建立，进一步加载网页数据。</a></p>
<h3 id="讲一讲对称加密和非对称加密"><a href="#讲一讲对称加密和非对称加密" class="headerlink" title="讲一讲对称加密和非对称加密"></a>讲一讲对称加密和非对称加密</h3><ul>
<li>对称加密是一种常用的加密方式，它有一个特点：就是加密和解密使用同一把密钥。也就是说，用这个密钥加密的信息，只有用同样的密钥才能解密。对称加密的速度相对较快，但是密钥的传输和保管比较困难，因为只要这个密钥被泄漏，任何人都可以解密信息。</li>
<li>为了解决这个问题，就需要使用到非对称加密技术，其中涉及到两个密钥：公钥和私钥。公钥是公开的，任何人都可以见到，并且可以用来加密信息或者验证签名。而私钥则是保密的，只有密钥的主人才能看到，用来解密信息或者生成签名。</li>
</ul>
<h3 id="讲一讲Cookie"><a href="#讲一讲Cookie" class="headerlink" title="讲一讲Cookie"></a>讲一讲Cookie</h3><blockquote>
<p><strong>Cookie是一种在客户端（浏览器）和服务器之间交换的小型数据文件</strong>。它由服务器生成并发送给客户端，然后客户端保存在本地的浏览器中。每次浏览器向同一服务器发送请求时，会将相应的Cookie信息附加在请求头中一起发送给服务器。</p>
</blockquote>
<p>Cookie主要用于记录和追踪与用户相关的信息</p>
<ul>
<li>会话管理：通过使用会话Cookie，服务器可以在用户的多个请求之间维持会话状态。它使服务器能够识别特定用户，并保持用户登录状态，而不需要用户在每个请求中重新验证身份。</li>
<li>用户个性化：Cookie可以用于存储用户的个人喜好、偏好或设置等信息。例如，在某个电子商务网站上，可以使用Cookie来记录用户的购物车内容和偏好选项，以便在用户下次访问时进行个性化推荐或还原购物车。</li>
<li>随机广告：Cookie可以用于进行广告跟踪和定向投放。广告商可以在用户访问某个网站时，通过Cookie记录用户的兴趣、浏览行为等信息，然后根据这些信息显示与用户兴趣相关的广告。</li>
<li>记住用户：通过在Cookie中存储持久性数据，网站可以实现”记住我”的功能，使用户在下次访问时不需要重新输入用户名和密码。</li>
</ul>
<h3 id="讲一讲Session"><a href="#讲一讲Session" class="headerlink" title="讲一讲Session"></a>讲一讲Session</h3><blockquote>
<p><strong>Session（会话）是指在客户端和服务器之间建立的一种会话状态</strong>。通过会话，服务器可以在不同请求之间识别和跟踪特定的客户端，并保持与客户端的交互状态。</p>
</blockquote>
<p>在Web应用中，Session通常使用一种名为Session ID的机制来实现。当客户端首次访问服务器时，服务器会为此客户端生成一个唯一的Session ID，并将其存储在服务器端的存储介质（如内存、数据库、文件）中，同时将该Session ID发送给客户端保存在Cookie中。</p>
<p>客户端在后续的请求中，会将存储在Cookie中的Session ID自动带上，供服务器在接收到请求时进行识别。然后，服务器根据Session ID找到相应的会话数据，使得服务器能够识别特定的客户端并维持会话状态。</p>
<h3 id="Cookie和Session的区别有哪些"><a href="#Cookie和Session的区别有哪些" class="headerlink" title="Cookie和Session的区别有哪些"></a>Cookie和Session的区别有哪些</h3><ul>
<li>存储位置：Cookie数据存储在客户端（浏览器），而Session数据存储在服务器端。因此，从保护用户数据的角度来看，Session比Cookie更安全。</li>
<li>生命周期：通常情况下，Cookie有固定的过期时间，除非用户手动清理否则不会消失，即使关闭浏览器或重启计算机也依然存在。而Session的生命周期通常是在用户关闭浏览器或者超出了设定的时间段后，服务器就会自动将其销毁。</li>
<li>大小限制：由于Cookie数据存储在客户端，所以它有大小限制，一般为4KB左右。而Session是存储在服务器端，理论上其数据大小没有限制，但是如果存储过多的数据会增加服务器的负担。</li>
<li>数据类型限制：Cookie只能保存字符串类型的数据，对于复杂的数据结构需要进行序列化。而Session可以存储任何类型的数据，比如对象和数组等。</li>
<li>跨域问题：基于安全性，Cookie不可以进行跨域名存储，每个域名下的Cookie数据是分开存储的。而Session技术没有这项限制。</li>
</ul>
<h3 id="Cookie和Session是如何实现用户的登陆状态的"><a href="#Cookie和Session是如何实现用户的登陆状态的" class="headerlink" title="Cookie和Session是如何实现用户的登陆状态的"></a>Cookie和Session是如何实现用户的登陆状态的</h3><ul>
<li>一旦用户通过输入正确用户名和密码登录，服务器就会创建一个会话（Session）并保存在服务端。这个Session具有唯一的ID。</li>
<li>服务器会创建一个新的Cookie，并将刚才Session的ID作为Cookie的一部分发送到用户的浏览器。这样，每次客户端向服务器请求时，Cookie就会包含在HTTP头信息中。</li>
<li>当接收到带有Cookie的请求时，服务器会对比Cookie中的Session ID与服务端保存的ID是否匹配。如果匹配，服务器就认为用户是已经登录的，然后就可以提供属于该用户的信息或服务。</li>
</ul>
<h3 id="URI和URL之间的区别"><a href="#URI和URL之间的区别" class="headerlink" title="URI和URL之间的区别"></a>URI和URL之间的区别</h3><blockquote>
<p>URI是一个广义的概念，用于唯一标识和识别互联网资源；而URL是URI的一种特殊形式，它不仅唯一标识和识别资源，还提供了访问和定位资源的详细信息。简单来说，URL是URI的一个具体实现。</p>
</blockquote>
<ul>
<li><strong>概念差异</strong>：URI是一个统一的标识符，用于唯一标识和识别资源。URL是URI的一种特定形式，它指定了资源在网络上的具体位置。URL是一种更具体的标识符，它指示了如何访问和定位资源。</li>
<li><strong>格式差异</strong>：URI由scheme（协议）、authority（权威部分）和path（路径）组成，形如：scheme:&#x2F;&#x2F;authority&#x2F;path。URL是URI的一种特殊形式，它包含了更详细的信息，包括scheme、authority、path以及其他额外的组件，如查询参数和片段标识符。</li>
<li><strong>用途差异</strong>：URI用于唯一标识和识别资源，它是资源的名称。URL除了唯一标识和识别资源外，还提供了访问和定位资源的方式和细节。</li>
</ul>
<h3 id="IPV4地址不够如何解决"><a href="#IPV4地址不够如何解决" class="headerlink" title="IPV4地址不够如何解决"></a>IPV4地址不够如何解决</h3><ul>
<li>IPv6（Internet Protocol Version 6）：IPv6 是 IPv4 的后继协议，扩展了地址空间，从而解决了 IPv4 地址不够的问题。</li>
<li>IP 地址转换技术：有些技术可以实现 IPv4 和 IPv6 地址之间的转换。例如，双栈技术（Dual-Stack）可以在同一设备上同时支持 IPv4 和 IPv6 协议栈，使设备可以在 IPv4 和 IPv6 网络中通信。</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%85%AB%E8%82%A1/" class="category-chain-item">八股</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%85%AB%E8%82%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="category-chain-item">计算机网络</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%85%AB%E8%82%A1/" class="print-no-link">#八股</a>
      
        <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="print-no-link">#计算机网络</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>计算机网络八股</div>
      <div>https://love-enough.github.io/2024/08/08/计算机网络八股/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>GuoZihan</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年8月8日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2024年8月9日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/08/07/%E7%BD%91%E6%98%93Java%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E4%B8%80%E9%9D%A2/" title="网易Java后台开发实习一面">
                        <span class="hidden-mobile">网易Java后台开发实习一面</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"6yoTduI2I2n2uTiOyxHOpVNZ-gzGzoHsz","appKey":"CuG32gSXDFOZPtNyZjx6BOYR","path":"window.location.pathname","placeholder":"给博主留下点什么吧！","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/vvd_js/duration.js"></script> </div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/scrollAnimation.js"></script>
<script src="/js/duration.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
